#ifndef MUJOCO_SRC_PLUGIN_ELASTICITY_WIRE_H_
#define MUJOCO_SRC_PLUGIN_ELASTICITY_WIRE_H_

#include <optional>
#include <vector>

#include <mujoco/mjdata.h>
#include <mujoco/mjmodel.h>
#include <mujoco/mjtnum.h>
#include <mujoco/mjvisualize.h>
#include <Eigen/Core>
#include <Eigen/Dense>
#include <Eigen/Geometry>

/*
- clean code - const, unnecessary class vars
- curved anisotropic theta optimization using 'newton_minimize' is untested,
  change 'boolThetaOpt' to 'true'
  from src to activate.
- replace mj_applyFT with torque addition 
  to current and subsequent child bodies,
  might save computation time.
- test baseomega
*/

namespace mujoco::plugin::elasticity {

// Node structure for wire simulation
struct Node {
  Eigen::Vector3d pos;
  Eigen::Quaterniond quat;
  double phi_i;
  double k;
  Eigen::Vector3d kb;
  Eigen::Matrix3d matframe;
  // material curvature
  Eigen::Matrix2d omega;  // col represents the i in omega^j_i
  Eigen::Matrix2d omegaBase;
};

// Edge structure for wire simulation
struct Edge {
  Eigen::Vector3d e;
  Eigen::Matrix3d bf;
  Eigen::Matrix3d matframe;
  double e_bar;
  double l_bar;
  Eigen::Vector3d torq; // Torque vector: [t,m1,m2]
  Eigen::Matrix2d B;   // bend stiffness
  double beta;         // twist stiffness
  double theta;
  double p_thetaloc;
  double theta_displace;
  Eigen::Quaterniond qe_o2m_loc;
};

/*
- theta is the overall rot
- theta_displace is the remainder of theta/(2*PI) that is mismatched with the material frame
- o2m is the conversion from sim frame to material frame
to get updateTheta,
  1. get material frame from interacted sim body quat
  2. add theta_displace and confine between -PI and PI, that is the thetaloc
  3. compare with p_thetaloc and update theta
  4. update p_thetaloc
  5. repeat at each compute
*/

class Wire {
 public:
  // Creates a new Wire instance (allocated with `new`) or
  // returns null on failure.
  static std::optional<Wire> Create(const mjModel* m, mjData* d, int instance);
  Wire(Wire&&) = default;
  ~Wire() = default;

  void Compute(const mjModel* m, mjData* d, int instance);
  void calculateEnergy();
  void Visualize(const mjModel* m, mjData* d, mjvScene* scn, int instance);

  static void RegisterPlugin();

  // Core simulation parameters
  int i0;                         // index of first body
  int n;                          // number of bodies in the wire
  mjtNum vmax;                    // max value in colormap

  bool flat;
  bool pqsActive;                 // PartialQuasistaticTwist on/off
  bool boolThetaOpt;                   // set to true to activate theta optimization with Newton's method
  bool boolIsoStr8;                   // check if bend stiffness is straight isotropic
  bool timing_enabled;
  bool calcEnergy;
  bool fullDyn;

  int someStiff;               // Only run for someStiff most bent nodes (compared to neighbours); off if 0
  std::vector<int> idStiffest;

  // DER cpp variables
  std::vector<int> qvel_addrs;  // Store all joint velocity addresses for plugin bodies
  std::vector<int> joint_nv;    // Store number of DOFs for each joint
  std::vector<Node, Eigen::aligned_allocator<Node>> nodes;
  std::vector<Edge, Eigen::aligned_allocator<Edge>> edges;
  int nv;
  double bigL_bar;
  Eigen::Matrix2d j_rot;
  std::vector<int> bodies_with_interactions;  // Stores indices of bodies with interactions
  std::vector<int> new_bwi;  // Stores previous step's bodies with interactions
  std::vector<mjtNum> plugin_torque;  // Store forces generated by this plugin
  double E_total = 0.0;

  double total_compute_time_ms = 0.0;
  int compute_call_count = 0;
  void PrintComputeTiming();

 private:
  // Update all variables from SimData
  void updateVars(mjData* d);
  // Bishop frame initialization
  void initBishopFrame();
  void updateBishopFrame(mjData* d);
  // init reference transform of Simframe to material frame
  void initO2M(mjData* d);
  void updateO2M(mjData* d, int idx);
  bool transfBF();
  double get_thetaloc(mjData* d, int idx);
  void updateTheta(double theta_loc, int idx);
  void splitTheta(int startId, int endId);
  void initBaseOmega();
  void updateMatFrame();

  // detecting interactions for PQS
  void updateNewBWI(mjData* d, int idx);
  void detectInteractions(const mjModel* m, mjData* d);
  void printInfo(const mjModel* m, mjData* d);

  // special smoothing condition
  void findLargestKbDeviations();

  // theta optimize for Anisotropic 
  double compute_energy(const Eigen::VectorXd& theta, int startId, int endId);
  Eigen::VectorXd compute_gradient(const Eigen::VectorXd& theta, int startId, int endId);
  void updateSingleMatFrame(double theta, int idx);

  void compute_tridiagonal_hessian(const Eigen::VectorXd& theta,
                                  int startId, int endId,
                                  std::vector<double>& lower,  // a: below diagonal (n-1)
                                  std::vector<double>& diag,   // b: diagonal (n)
                                  std::vector<double>& upper);  // c: above diagonal (n-1)
  void solve_tridiagonal(const std::vector<double>& lower,
                       const std::vector<double>& diag,
                       const std::vector<double>& upper,
                       const Eigen::VectorXd& rhs,
                       Eigen::VectorXd& x);
  double line_search(const Eigen::VectorXd& theta,
                    int startId, int endId,
                    const Eigen::VectorXd& direction,
                    const Eigen::VectorXd& grad,
                    double alpha = 1.0,
                    double rho = 0.5,
                    double c = 1e-4);
  void newton_minimize(Eigen::VectorXd& theta,
                    int startId, int endId,
                    int max_iters = 50,
                    double tol = 1e-6);

  Wire(const mjModel* m, mjData* d, int instance);
};

}  // namespace mujoco::plugin::elasticity

#endif  // MUJOCO_SRC_PLUGIN_ELASTICITY_WIRE_H_
